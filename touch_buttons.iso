#include <stdint.h>
#include <SeeedTouchScreen.h> 
#include <TFTv2.h>
#include <SPI.h>

#define YP A2   // must be an analog pin, use "An" notation!
#define XM A1   // must be an analog pin, use "An" notation!
#define YM 14   // can be a digital pin, this is A0
#define XP 17   // can be a digital pin, this is A3 

//Measured ADC values for (0,0) and (210-1,320-1)
//TS_MINX corresponds to ADC value when X = 0
//TS_MINY corresponds to ADC value when Y = 0
//TS_MAXX corresponds to ADC value when X = 240 -1
//TS_MAXY corresponds to ADC value when Y = 320 -1

#define TS_MINX 116*2
#define TS_MAXX 890*2
#define TS_MINY 83*2
#define TS_MAXY 913*2

#define backLight 7

#define relayOne 8
#define relayTwo 9
#define relayThree 10
#define relayFour 11

int buttonOneState = 1; // setting variable for button 1 state
int buttonTwoState = 1; // setting variable for button 2 state
int buttonThreeState = 1;
int buttonFourState = 1;
int buttonFiveState = 1;

long LastTouchMillis = 0; // variable to hold the last time the screen was touched
long sleepInterval = (300000); // a five minute interval to be used in conjunction with screen sleep

// For better pressure precision, we need to know the resistance
// between X+ and X- Use any multimeter to read it
// The 2.8" TFT Touch shield has 300 ohms across the X plate
TouchScreen ts = TouchScreen(XP, YP, XM, YM);

void setup(void) {
  Serial.begin(9600);
  Tft.TFTinit(); //Start Screen
  digitalWrite(backLight,HIGH); // turn on the backlight
  
  pinMode(backLight,OUTPUT); //
  
  pinMode (relayOne, OUTPUT); 
  pinMode (relayTwo, OUTPUT);
  pinMode (relayThree, OUTPUT);
  pinMode (relayFour, OUTPUT);
  
  Tft.drawString("B1",50,10,2,WHITE); // button lable
  Tft.drawString("B2",170,10,2,WHITE); // button lable
  Tft.drawString("B3",50,115,2,WHITE);
  Tft.drawString("B4",170,115,2,WHITE);
  OffBox(20,25); //initial drawing of button
  OffBox(140,25); //initial drawing of button
  OffBox(20,130);
  OffBox(140,130);
  OffBox(80,230);
}

void loop(void) {
  backLightState(); // screen sleep/wake function
  
  Point p = ts.getPoint();  // a point object holds x y (location) and z (pressure) coordinates
  p.x = map(p.x, TS_MINX, TS_MAXX, 0, 240); //x coordinate 
  p.y = map(p.y, TS_MINY, TS_MAXY, 0, 320); //y coordinate

  // we have some minimum pressure we consider 'valid', so p.z needs to be more than 0 to indicate a touch and resulting action
  if (p.z > 50) {
    Serial.print("X = "); Serial.print(p.x);
    Serial.print("\tY = "); Serial.print(p.y);
    Serial.print("\tPressure = "); Serial.println(p.z);
    Serial.println(buttonOneState);
      /////////BUTTON 1////////////
      if (25<=p.x && p.x<=105 && 20<=p.y && p.y<=100) {
        if (buttonOneState == 1) {
            OnBox(20,25);
            digitalWrite(relayOne,0);
            Serial.println(buttonOneState);
            buttonOneState = 0;
            delay(500);
          }
        else { 
           OffBox(20,25);
           digitalWrite(relayOne,1);
           buttonOneState = 1;
           delay(100);
          }
      }
      ////////////BUTTON 2///////////////
      else if (140<=p.x && p.x<=220 && 20<=p.y && p.y<=100) {
         if (buttonTwoState == 1) {
            OnBox(140,25);
            digitalWrite(relayTwo,0);
            Serial.println(buttonTwoState);
            buttonTwoState = 0;
            delay(100);
          }
        else { 
           OffBox(140,25);
           digitalWrite(relayTwo,1);
           buttonTwoState = 1;
           delay(500);
        }
      }
      /////////////BUTTON 3///////////
      else if (20<=p.x && p.x<=100 && 130<=p.y && p.y<=210) {
        if (buttonThreeState == 1) {
            OnBox(20,130);
            digitalWrite(relayOne,0);
            Serial.println(buttonOneState);
            buttonThreeState = 0;
            delay(100);
          }
        else { 
           OffBox(20,130);
           digitalWrite(relayOne,1);
           buttonThreeState = 1;
           delay(100);
          }
      }
      //////////BUTTON 4//////////
      else if (140<=p.x && p.x<=220 && 130<=p.y && p.y<=210) {
         if (buttonFourState == 1) {
            OnBox(140,130);
            digitalWrite(relayTwo,0);
            Serial.println(buttonTwoState);
            buttonFourState = 0;
            delay(100);
          }
        else { 
           OffBox(140,130);
           digitalWrite(relayTwo,1);
           buttonFourState = 1;
           delay(100);
      }
    }
    //////////MASTER ON OFF SWITCH/////////////
        else if (80 <=p.x && p.x <= 160 && 230 <p.y && p.y <=310){
          if (buttonFiveState == 1) {
             OnBox(80,230);
             OnBox(20,25);
             OnBox(140,25); 
             OnBox(20,130);
             OnBox(140,130);
             buttonOneState = 0;
             buttonTwoState = 0;
             buttonThreeState = 0;
             buttonFourState = 0;
             buttonFiveState = 0;
          }
          else {
             OffBox(80,230);
             OffBox(20,25);
             OffBox(140,25); 
             OffBox(20,130);
             OffBox(140,130);
             buttonOneState = 1;
             buttonTwoState = 1;
             buttonThreeState = 1;
             buttonFourState = 1;
             buttonFiveState = 1;
        }
     }
  }
  delay(100);
}

///////////////////////////////Box Helpers////////////////////////////

int OnBox(int px, int py){
  Tft.fillRectangle(px,py,84,84,BLACK);
  Tft.fillRectangle(px+4, py+4, 80, 80, RED);
  Tft.drawRectangle(px,py,83,83, WHITE);
  Tft.drawRectangle(px,py,84,84, WHITE);
  Tft.drawString("ON",px+20,py+30,3,WHITE);
}

int OffBox(int px, int py){
  Tft.fillRectangle(px,py,84,84,BLACK);
  Tft.fillRectangle(px, py, 80, 80, GREEN);
  Tft.drawRectangle(px,py,83,83, WHITE);
  Tft.drawRectangle(px,py,84,84, WHITE);
  Tft.drawString("OFF", px+10, py+25, 3, WHITE);
}  

////////////////////////////Additional Functions/////////////////////////////////

void backLightState() {
  Point p = ts.getPoint(); 
  unsigned long currentMillis = millis();
  if (p.z >=5) {
    LastTouchMillis = millis();
  }
  else if ((currentMillis - LastTouchMillis) > sleepInterval && p.z <= 5) {
    digitalWrite(backLight,LOW);  
  }
  else {
    digitalWrite(backLight,HIGH);
  }
}
